{"paragraphs":[{"text":"%pyspark\n### Tarea 7\n\nfrom pyspark.sql import SparkSession \nfrom pyspark.ml import Pipeline\nfrom pyspark.ml.tuning import CrossValidator, ParamGridBuilder\nfrom pyspark.ml.feature import StringIndexer\nfrom pyspark.ml.linalg import Vectors\nfrom pyspark.ml.feature import VectorAssembler\nfrom pyspark.ml.tuning import CrossValidator, ParamGridBuilder\nfrom pyspark.ml.evaluation import RegressionEvaluator\nfrom pyspark.ml.regression import RandomForestRegressor\nfrom pyspark.ml.regression import GBTRegressor\nimport time\n\n## Lee el archivo Tarea 7 \n\nspark = SparkSession.builder.appName('\"Tarea_7\"').getOrCreate() \n\n#flights = spark.read.csv('metodos_gran_escala/flights/flights.csv', header = True, inferSchema = True, nullValue = 'null')\nflights = spark.read.csv('s3n://metodosgranescala/tarea7/datos/flights.csv', header = True, inferSchema = True, nullValue = 'null')\n\n## Seleccionando los registros que no tienen nulo DEPARTURE DELAY \nflights = flights.filter(\"DEPARTURE_DELAY is not NULL\")\n\n## Seleccionando los campos relacionados a DEPARTURE_DELAY \nflights = flights.select(\"MONTH\",\"DAY\",\"DAY_OF_WEEK\",\"AIRLINE\",\"FLIGHT_NUMBER\",\"ORIGIN_AIRPORT\",\"DESTINATION_AIRPORT\",\"SCHEDULED_DEPARTURE\",\"DEPARTURE_TIME\",\"DEPARTURE_DELAY\",\"TAXI_OUT\",\"ELAPSED_TIME\",\"AIR_TIME\",\"DISTANCE\",\"TAXI_IN\",\"SCHEDULED_ARRIVAL\",\"ARRIVAL_TIME\",\"ARRIVAL_DELAY\")\nflights = flights.na.drop(subset=[\"MONTH\",\"DAY\",\"DAY_OF_WEEK\",\"AIRLINE\",\"FLIGHT_NUMBER\",\"ORIGIN_AIRPORT\",\"DESTINATION_AIRPORT\",\"SCHEDULED_DEPARTURE\",\"DEPARTURE_TIME\",\"DEPARTURE_DELAY\",\"TAXI_OUT\",\"ELAPSED_TIME\",\"AIR_TIME\",\"DISTANCE\",\"TAXI_IN\",\"SCHEDULED_ARRIVAL\",\"ARRIVAL_TIME\",\"ARRIVAL_DELAY\"])\n\n## Transformar las variables de tipo string a una columna con indices por etiqueta\n\nAIRLINE_indexer             = StringIndexer(inputCol='AIRLINE',outputCol='AIRLINE_idx',handleInvalid='skip')\nORIGIN_AIRPORT_indexer      = StringIndexer(inputCol='ORIGIN_AIRPORT',outputCol='ORIGIN_AIRPORT_idx',handleInvalid='skip')\nDESTINATION_AIRPORT_indexer = StringIndexer(inputCol='DESTINATION_AIRPORT',outputCol='DESTINATION_AIRPORT_idx',handleInvalid='skip')\n\n## Separamos los conjutos de entrenamiento y prueba\n\n(trainingData, testData) = flights.randomSplit([0.7, 0.3])\n      \n## Combinamos las columnas en una sola de features \nassembler = VectorAssembler(inputCols=[ \"MONTH\",\"DAY\",\"DAY_OF_WEEK\",\"AIRLINE_idx\",\"FLIGHT_NUMBER\",\"ORIGIN_AIRPORT_idx\",\n                                        \"DESTINATION_AIRPORT_idx\",\"SCHEDULED_DEPARTURE\",\"DEPARTURE_TIME\",\"TAXI_OUT\",\n                                        \"ELAPSED_TIME\",\"AIR_TIME\",\"DISTANCE\",\"TAXI_IN\",\"SCHEDULED_ARRIVAL\",\n                                        \"ARRIVAL_TIME\",\"ARRIVAL_DELAY\"], outputCol='features')\n\n\n## Definimos dos modelos a utilizar, un randrom tree y un gradient boost \n\nrf =  RandomForestRegressor(featuresCol=\"features\",labelCol=\"DEPARTURE_DELAY\",maxBins=1000)\ngbt = GBTRegressor(featuresCol=\"features\",labelCol=\"DEPARTURE_DELAY\",maxBins=1000)\n\nparam_rf =  ParamGridBuilder().addGrid(rf.maxDepth, [1, 2, 3]).addGrid(rf.numTrees, [5,10]).build()\nparam_gbt = ParamGridBuilder().addGrid(gbt.maxDepth, [1, 2, 3]).addGrid(gbt.maxIter, [5,10]).build()\n\nmodelos =[rf, gbt]\ngrid = [param_rf, param_gbt]\n\n\n## Definimos la funcion magic loop para buscar el mejor modelo\n\ndef magic_loop(crossFolds,train,test):\n    mejor_modelo = []\n    metricas = []\n    parametros = []    \n    for i in [0,1]:\n        pipeline = Pipeline(stages=[AIRLINE_indexer, ORIGIN_AIRPORT_indexer, DESTINATION_AIRPORT_indexer, assembler, modelos[i]]) \n        crossValidator = CrossValidator(estimator=pipeline, estimatorParamMaps=grid[i],evaluator=RegressionEvaluator(predictionCol='prediction', labelCol=\"DEPARTURE_DELAY\", metricName='rmse'),numFolds=crossFolds)\n        crossValidatorModel = crossValidator.fit(train)\n        mejor_modelo.append(crossValidatorModel.bestModel)\n        metricas.append(min(crossValidatorModel.avgMetrics))\n        parametros.append(grid[i][crossValidatorModel.avgMetrics.index(min(crossValidatorModel.avgMetrics))])\n    print('Mejor modelo es:',parametros[metricas.index(min(metricas))]) \n    return(mejor_modelo[metricas.index(min(metricas))])\n","user":"anonymous","dateUpdated":"2018-04-26T06:15:28+0000","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"python","editOnDblClick":false},"editorMode":"ace/mode/python"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[]},"apps":[],"jobName":"paragraph_1524723192854_-1437529612","id":"20180426-061312_771123479","dateCreated":"2018-04-26T06:13:12+0000","dateStarted":"2018-04-26T06:15:28+0000","dateFinished":"2018-04-26T06:15:36+0000","status":"FINISHED","progressUpdateIntervalMs":500,"focus":true,"$$hashKey":"object:374"},{"text":"%pyspark\n\nstart = time.time()\nresultado = magic_loop(10,trainingData,testData)\nend = time.time()\n\nprint(\"Tiempo de ejecución (minutos): \", (end-start)/60)\n","user":"anonymous","dateUpdated":"2018-04-26T06:16:27+0000","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"TEXT","data":"('Mejor modelo es:', {Param(parent=u'GBTRegressor_4e32a53ab3f017353692', name='maxIter', doc='max number of iterations (>= 0).'): 10, Param(parent=u'GBTRegressor_4e32a53ab3f017353692', name='maxDepth', doc='Maximum depth of the tree. (>= 0) E.g., depth 0 means 1 leaf node; depth 1 means 1 internal node + 2 leaf nodes.'): 3})\n('Tiempo de ejecuci\\xc3\\xb3n (minutos): ', 85.918354900678)\n"}]},"apps":[],"jobName":"paragraph_1524723219481_-1517911484","id":"20180426-061339_1924967578","dateCreated":"2018-04-26T06:13:39+0000","dateStarted":"2018-04-26T06:16:27+0000","dateFinished":"2018-04-26T07:42:22+0000","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:375"},{"text":"%pyspark\n","user":"anonymous","dateUpdated":"2018-04-26T06:16:27+0000","config":{"colWidth":12,"enabled":true,"results":{},"editorSetting":{"language":"scala","editOnDblClick":false},"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1524723387144_836026615","id":"20180426-061627_1192219152","dateCreated":"2018-04-26T06:16:27+0000","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:376"}],"name":"Tarea 7","id":"2DDUVP9GR","angularObjects":{"2BRWU4WXC:shared_process":[],"2AM1YV5CU:shared_process":[],"2AJXGMUUJ:shared_process":[],"2ANGGHHMQ:shared_process":[],"2AKK3QQXU:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}